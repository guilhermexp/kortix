---
title: 'Self Hosting'
description: 'Guia oficial para rodar o Supermemory em infraestrutura própria (Supabase + Bun)'
---

## Visão geral

A stack self-hosted roda inteira dentro deste monorepo:

- **Banco**: Supabase Postgres com pgvector habilitado
- **Backend**: `apps/api` (Bun + Hono)
- **Frontend**: `apps/web` (Next.js 15)
- **Autenticação**: better-auth com envio de e-mails via Resend
- **MCP**: exposto em `${SUPERMEMORY_API_URL}/mcp`

O objetivo deste guia é colocar tudo online sem depender de `api.supermemory.ai`, Cloudflare Workers ou qualquer infraestrutura do SaaS original.

## Pré-requisitos

1. **Projeto Supabase** com pgvector habilitado. O plano gratuito já funciona para desenvolvimento.
2. **Resend API Key** (ou outro provider SMTP/Email que você plugar no `mailer.ts`).
3. **Chave do provedor de LLM/embeddings** (Gemini por padrão, configure `GOOGLE_API_KEY`).
4. Ambiente capaz de rodar Bun ≥ 1.2 e Node ≥ 20 (para build do Next.js).
5. Opcional: domínio público + reverse proxy (Caddy, Nginx, Fly.io, Render, etc.).

## 1. Provisionar o Supabase

1. Crie um projeto em [https://supabase.com](https://supabase.com).
2. Ative `pgvector`: **SQL Editor → Extensions → pgvector → Enable**.
3. Anote:
   - `SUPABASE_URL`
   - `SUPABASE_ANON_KEY`
   - `SUPABASE_SERVICE_ROLE_KEY`
   - `SUPABASE_DB_URL` (disponível em **Project Settings → Database → Connection string**)
4. Execute os arquivos em `spec/infra/migrations` na ordem para garantir o schema atualizado (pode usar a aba SQL ou o MCP do Supabase já configurado no repositório).
5. Rode o seed inicial (`spec/infra/seeds/0001_default_org.sql`) para criar organização, admin e projeto padrão.

## 2. Configurar variáveis de ambiente

### Backend (`apps/api/.env`)

```ini
PORT=4000
SUPABASE_URL=https://SEU_PROJETO.supabase.co
SUPABASE_ANON_KEY=...
SUPABASE_SERVICE_ROLE_KEY=...
SUPABASE_DATABASE_URL=postgresql://postgres:senha@host:5432/postgres
AUTH_SECRET=chave_com_32_caracteres
APP_URL=https://app.seudominio.com
ALLOWED_ORIGINS=https://app.seudominio.com,http://localhost:3000
GOOGLE_API_KEY=sua_key_do_modelo
SUMMARY_MODEL=models/gemini-2.5-pro
FIRECRAWL_API_KEY= # opcional, usa Firecrawl para normalizar páginas web
RESEND_API_KEY=sua_key_resend
FROM_EMAIL=suporte@seudominio.com
```

### Frontend (`apps/web/.env`)

```ini
NEXT_PUBLIC_BACKEND_URL=https://api.seudominio.com
NEXT_PUBLIC_APP_URL=https://app.seudominio.com
NEXT_PUBLIC_MCP_SERVER_URL=https://api.seudominio.com/mcp
NEXT_PUBLIC_DOCS_URL=https://app.seudominio.com/docs
```

> Para desenvolvimento local, use `http://localhost:4000` e `http://localhost:3000` respectivamente.

## 3. Rodar em desenvolvimento

```bash
bun install
bun run --cwd apps/api dev      # backend em http://localhost:4000
bun run --cwd apps/web dev      # frontend em http://localhost:3000
```

Crie sua conta pelo frontend (usa better-auth) e confirme o fluxo completo: login, criação de documentos, busca e chat.

## 4. Deploy de produção

### Backend (Bun)

Você pode usar qualquer processo supervisor. Exemplo com **PM2**:

```bash
pm2 start --name supermemory-api bun -- run start --cwd apps/api
```

Ou construir uma imagem Docker:

```Dockerfile
FROM oven/bun:1.2
WORKDIR /app
COPY . .
RUN bun install --production
WORKDIR /app/apps/api
CMD ["bun", "run", "start"]
```

Lembre-se de expor a porta 4000 (ou a que configurar) e apontar o proxy / domínio para esse serviço.

### Frontend (Next.js)

```bash
cd apps/web
bun run build
bun run start
```

A build do Next utiliza as envs de `.env`. Sirva atrás do mesmo proxy ou utilize plataformas como Vercel/Fly apontando `NEXT_PUBLIC_BACKEND_URL` para o domínio do backend.

## 5. E-mails e autenticação

- `packages/auth-server/mailer.ts` usa Resend. Configure o domínio e ajuste o `FROM_EMAIL`.
- Se quiser SMTP próprio, adapte esse arquivo mantendo a mesma interface.
- RLS do Supabase depende das seeds executadas; revise `spec/infra/migrations/0002_*` para políticas atualizadas.
- Ingestão multimídia: com `GOOGLE_API_KEY` ativo o backend usa Gemini para resumir YouTube, imagens, áudio, vídeo e documentos (PDF, DOCX, PPTX, planilhas). Configure `FIRECRAWL_API_KEY` para padronizar páginas web antes do chunking.

## 6. MCP e conectores

- MCP: já exposto em `${BACKEND_URL}/mcp`. Relembre o [guia de setup](/supermemory-mcp/setup).
- Conectores (Notion, Google Drive, etc.) ainda dependem de credenciais próprias; coloque-as nas envs do backend quando for ativar cada integração.

## 7. Checklist pós-deploy

- [ ] Backend responde `GET /health` com `200`.
- [ ] Frontend acessível e apontando para o backend correto.
- [ ] Login por e-mail funcionando (verifique entrega de Resend).
- [ ] Upload/ingestão de documentos gera memórias consultáveis em `/v3/search`.
- [ ] Uploads multimídia (PDF, DOCX, imagens, áudio, vídeo, YouTube) são resumidos automaticamente pelo Gemini/Firecrawl.
- [ ] Chat responde utilizando contexto das memórias.
- [ ] MCP conectado (se aplicável).

Caso algo falhe, consulte os logs (`pm2 logs`, `docker logs` ou `bun run --cwd apps/api dev` em modo verbose). O diretório `spec/` contém detalhes da arquitetura e o status atualizado do schema Supabase.
