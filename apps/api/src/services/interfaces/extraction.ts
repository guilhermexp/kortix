/**
 * Document Extraction Interfaces
 *
 * This file contains interfaces specific to document extraction functionality.
 * Each extractor type has its own specialized interface while adhering to a
 * common base interface.
 *
 * Extractor Types:
 * - URLExtractor: Web URLs using MarkItDown
 * - YouTubeExtractor: YouTube videos with transcript extraction
 * - PDFExtractor: PDF documents with OCR fallback
 * - FileExtractor: Office documents (DOCX, XLSX, etc.)
 */

import type {
	BaseService,
	ExtractionInput,
	ExtractionResult,
	ProcessingError,
	RetryOptions,
} from "./document-processing"

// ============================================================================
// Base Extractor Interface
// ============================================================================

/**
 * Base interface for all document extractors
 */
export interface DocumentExtractor extends BaseService {
	/**
	 * Extract content from the given input
	 */
	extract(input: ExtractionInput): Promise<ExtractionResult>

	/**
	 * Check if this extractor can handle the given input
	 */
	canHandle(input: ExtractionInput): boolean

	/**
	 * Get extractor priority (higher = preferred)
	 */
	getPriority(): number

	/**
	 * Validate input before extraction
	 */
	validateInput(input: ExtractionInput): Promise<void>
}

// ============================================================================
// Specialized Extractor Interfaces
// ============================================================================

/**
 * URL-based web content extractor using MarkItDown
 */
export interface URLExtractor extends DocumentExtractor {
	/**
	 * Extract content from a web URL using MarkItDown
	 */
	extractFromUrl(
		url: string,
		options?: URLExtractorOptions,
	): Promise<ExtractionResult>

	/**
	 * Check service health
	 */
	checkServiceHealth(): Promise<boolean>

	/**
	 * Get rate limit information
	 */
	getRateLimitInfo(): Promise<RateLimitInfo>
}

/**
 * URL extraction options
 */
export interface URLExtractorOptions {
	/** Include main content only */
	onlyMainContent?: boolean
	/** Include markdown formatting */
	includeMarkdown?: boolean
	/** Include HTML */
	includeHtml?: boolean
	/** Include links */
	includeLinks?: boolean
	/** Maximum content length */
	maxContentLength?: number
	/** Wait for selector */
	waitForSelector?: string
	/** Timeout in milliseconds */
	timeout?: number
}

/**
 * Rate limit information
 */
export interface RateLimitInfo {
	/** Requests remaining */
	remaining: number
	/** Rate limit reset time */
	resetTime: Date
	/** Total limit */
	limit: number
	/** Current usage */
	used: number
}

/**
 * YouTube video content extractor
 */
export interface YouTubeExtractor extends DocumentExtractor {
	/**
	 * Extract transcript from YouTube video
	 */
	extractTranscript(
		videoId: string,
		options?: YouTubeOptions,
	): Promise<ExtractionResult>

	/**
	 * Extract metadata from YouTube video
	 */
	extractMetadata(videoId: string): Promise<YouTubeMetadata>

	/**
	 * Parse YouTube URL to get video ID
	 */
	parseVideoId(url: string): string | null

	/**
	 * Check if URL is a valid YouTube URL
	 */
	isYouTubeUrl(url: string): boolean
}

/**
 * YouTube extraction options
 */
export interface YouTubeOptions {
	/** Preferred language codes (e.g., ['en', 'en-US']) */
	preferredLanguages?: string[]
	/** Include auto-generated transcripts */
	includeAutoGenerated?: boolean
	/** Include timestamps */
	includeTimestamps?: boolean
	/** Minimum transcript length */
	minLength?: number
	/** Timeout in milliseconds */
	timeout?: number
}

/**
 * YouTube video metadata
 */
export interface YouTubeMetadata {
	/** Video ID */
	videoId: string
	/** Video title */
	title: string
	/** Channel name */
	channelName: string
	/** Video description */
	description: string
	/** Video duration in seconds */
	duration: number
	/** View count */
	viewCount?: number
	/** Upload date */
	uploadDate?: Date
	/** Available languages */
	availableLanguages: string[]
	/** Thumbnail URL */
	thumbnailUrl?: string
}

/**
 * PDF document extractor with OCR support
 */
export interface PDFExtractor extends DocumentExtractor {
	/**
	 * Extract text from PDF
	 */
	extractFromPDF(
		buffer: Buffer,
		options?: PDFOptions,
	): Promise<ExtractionResult>

	/**
	 * Extract text using OCR
	 */
	extractWithOCR(
		buffer: Buffer,
		options?: OCROptions,
	): Promise<ExtractionResult>

	/**
	 * Check if PDF is scanned (needs OCR)
	 */
	isScannedPDF(buffer: Buffer): Promise<boolean>

	/**
	 * Extract metadata from PDF
	 */
	extractMetadata(buffer: Buffer): Promise<PDFMetadata>
}

/**
 * PDF extraction options
 */
export interface PDFOptions {
	/** Use OCR for text extraction */
	useOCR?: boolean
	/** OCR provider */
	ocrProvider?: "replicate" | "gemini"
	/** Extract images */
	extractImages?: boolean
	/** Maximum pages to process */
	maxPages?: number
	/** Page range to extract (e.g., [1, 10]) */
	pageRange?: [number, number]
	/** Timeout in milliseconds */
	timeout?: number
}

/**
 * OCR extraction options
 */
export interface OCROptions {
	/** OCR provider */
	provider: "replicate" | "gemini"
	/** Language hint */
	language?: string
	/** Image preprocessing */
	preprocess?: boolean
	/** Confidence threshold (0-1) */
	confidenceThreshold?: number
	/** Timeout in milliseconds */
	timeout?: number
}

/**
 * PDF metadata
 */
export interface PDFMetadata {
	/** Document title */
	title?: string
	/** Document author */
	author?: string
	/** Document subject */
	subject?: string
	/** Document keywords */
	keywords?: string[]
	/** Creation date */
	creationDate?: Date
	/** Modification date */
	modificationDate?: Date
	/** Number of pages */
	pageCount: number
	/** File size in bytes */
	fileSize: number
	/** PDF version */
	pdfVersion?: string
	/** Is encrypted */
	isEncrypted: boolean
	/** Is scanned */
	isScanned?: boolean
}

/**
 * Office file extractor (DOCX, XLSX, PPTX, etc.)
 */
export interface FileExtractor extends DocumentExtractor {
	/**
	 * Extract content from office file
	 */
	extractFromFile(
		buffer: Buffer,
		fileName: string,
		mimeType: string,
		options?: FileOptions,
	): Promise<ExtractionResult>

	/**
	 * Check if file type is supported
	 */
	isSupported(mimeType: string): boolean

	/**
	 * Extract metadata from file
	 */
	extractMetadata(buffer: Buffer, mimeType: string): Promise<FileMetadata>
}

/**
 * File extraction options
 */
export interface FileOptions {
	/** Include formatting */
	includeFormatting?: boolean
	/** Extract images */
	extractImages?: boolean
	/** Maximum file size in bytes */
	maxFileSize?: number
	/** Timeout in milliseconds */
	timeout?: number
}

/**
 * File metadata
 */
export interface FileMetadata {
	/** File name */
	fileName: string
	/** MIME type */
	mimeType: string
	/** File size in bytes */
	fileSize: number
	/** Creation date */
	creationDate?: Date
	/** Modification date */
	modificationDate?: Date
	/** Author */
	author?: string
	/** Title */
	title?: string
	/** Additional properties */
	properties?: Record<string, unknown>
}

// ============================================================================
// Extractor Chain & Fallback Types
// ============================================================================

/**
 * Configuration for extractor chain with fallbacks
 */
export interface ExtractorChainConfig {
	/** List of extractors in priority order */
	extractors: DocumentExtractor[]
	/** Retry options for each extractor */
	retryOptions?: RetryOptions
	/** Whether to stop on first success */
	stopOnSuccess?: boolean
	/** Maximum time for entire chain */
	maxChainTime?: number
}

/**
 * Result from extractor chain execution
 */
export interface ChainExecutionResult {
	/** Extraction result */
	result: ExtractionResult
	/** Extractor that succeeded */
	successfulExtractor: string
	/** Extractors that were tried */
	attemptedExtractors: string[]
	/** Errors from failed extractors */
	errors: Map<string, ProcessingError>
	/** Total execution time */
	executionTime: number
}

/**
 * Extractor chain for fallback logic
 */
export interface ExtractorChain {
	/**
	 * Execute extraction with fallback chain
	 */
	execute(input: ExtractionInput): Promise<ChainExecutionResult>

	/**
	 * Add extractor to chain
	 */
	addExtractor(extractor: DocumentExtractor): void

	/**
	 * Remove extractor from chain
	 */
	removeExtractor(extractorName: string): void

	/**
	 * Get chain configuration
	 */
	getConfig(): ExtractorChainConfig
}

// ============================================================================
// Validation & Sanitization Types
// ============================================================================

/**
 * Input validation rules
 */
export interface ValidationRules {
	/** Maximum content length */
	maxContentLength?: number
	/** Maximum URL length */
	maxUrlLength?: number
	/** Allowed URL schemes */
	allowedSchemes?: string[]
	/** Blocked domains */
	blockedDomains?: string[]
	/** Allowed MIME types */
	allowedMimeTypes?: string[]
	/** Maximum file size */
	maxFileSize?: number
}

/**
 * Content sanitization options
 */
export interface SanitizationOptions {
	/** Remove null bytes */
	removeNullBytes?: boolean
	/** Normalize whitespace */
	normalizeWhitespace?: boolean
	/** Remove control characters */
	removeControlChars?: boolean
	/** Maximum length */
	maxLength?: number
	/** Trim content */
	trim?: boolean
}

/**
 * Validator for extraction input
 */
export interface ExtractionValidator {
	/**
	 * Validate extraction input
	 */
	validate(input: ExtractionInput, rules?: ValidationRules): Promise<void>

	/**
	 * Sanitize extraction result
	 */
	sanitize(
		result: ExtractionResult,
		options?: SanitizationOptions,
	): ExtractionResult

	/**
	 * Check if URL is safe
	 */
	isUrlSafe(url: string): Promise<boolean>

	/**
	 * Check if content is valid
	 */
	isContentValid(content: string): boolean
}

// ============================================================================
// Extraction Metadata Types
// ============================================================================

/**
 * Meta tags extracted from web pages
 */
export interface MetaTags {
	/** Page title */
	title?: string
	/** Page description */
	description?: string
	/** Open Graph image */
	ogImage?: string
	/** Twitter card image */
	twitterImage?: string
	/** Favicon URL */
	favicon?: string
	/** Author */
	author?: string
	/** Keywords */
	keywords?: string[]
	/** Canonical URL */
	canonicalUrl?: string
	/** Language */
	language?: string
	/** Additional meta tags */
	additional?: Record<string, string>
}

/**
 * Complete extraction metadata
 */
export interface ExtractionMetadata {
	/** Extraction timestamp */
	timestamp: Date
	/** Extractor used */
	extractor: string
	/** Extraction method */
	method: string
	/** Extraction duration in milliseconds */
	duration: number
	/** Success status */
	success: boolean
	/** Errors encountered */
	errors?: ProcessingError[]
	/** Retry count */
	retryCount: number
	/** Meta tags (for web pages) */
	metaTags?: MetaTags
	/** Additional metadata */
	additional?: Record<string, unknown>
}
