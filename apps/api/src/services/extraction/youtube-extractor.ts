/**
 * YouTube Extractor
 *
 * Specialized extractor for YouTube videos.
 * Features:
 * - YouTube video ID extraction from various URL formats
 * - Transcript extraction with language preferences
 * - Metadata extraction (title, description, duration, channel)
 * - Fallback to metadata only if transcript fails
 * - Support for auto-generated transcripts
 */

import { BaseService } from "../base/base-service"
import type {
	ExtractionInput,
	ExtractionResult,
	YouTubeExtractor as IYouTubeExtractor,
	YouTubeMetadata,
	YouTubeOptions,
} from "../interfaces"
import { fetchYouTubeTranscriptFallback } from "../markitdown"
import { summarizeYoutubeVideo } from "../summarizer"

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Fetch video title using YouTube oEmbed API (free, no auth required)
 */
async function fetchTitleFromOEmbed(videoId: string): Promise<string | null> {
	try {
		const url = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`
		const response = await fetch(url, { signal: AbortSignal.timeout(5000) })
		if (!response.ok) return null
		const data = await response.json()
		return data.title || null
	} catch {
		return null
	}
}

// ============================================================================
// YouTube Extractor Implementation
// ============================================================================

/**
 * Extractor for YouTube videos
 */
export class YouTubeExtractor extends BaseService implements IYouTubeExtractor {
	private readonly preferredLanguages: string[]

	constructor(preferredLanguages?: string[]) {
		super("YouTubeExtractor")
		this.preferredLanguages = preferredLanguages || [
			"en",
			"en-US",
			"pt",
			"pt-BR",
		]
	}

	// ========================================================================
	// DocumentExtractor Interface
	// ========================================================================

	/**
	 * Extract content from the given input
	 */
	async extract(input: ExtractionInput): Promise<ExtractionResult> {
		this.assertInitialized()

		if (!input.url) {
			throw this.createError(
				"MISSING_URL",
				"URL is required for YouTube extraction",
			)
		}

		const videoId = this.parseVideoId(input.url)
		if (!videoId) {
			throw this.createError("INVALID_YOUTUBE_URL", "Invalid YouTube URL")
		}

		return await this.extractTranscript(videoId, {
			preferredLanguages: this.preferredLanguages,
			includeAutoGenerated: true,
			includeTimestamps: false,
		})
	}

	/**
	 * Check if this extractor can handle the given input
	 */
	canHandle(input: ExtractionInput): boolean {
		if (!input.url) return false
		return this.isYouTubeUrl(input.url)
	}

	/**
	 * Get extractor priority (higher = preferred)
	 */
	getPriority(): number {
		return 15 // High priority for YouTube URLs
	}

	/**
	 * Validate input before extraction
	 */
	async validateInput(input: ExtractionInput): Promise<void> {
		if (!input.url) {
			throw this.createError("VALIDATION_ERROR", "URL is required")
		}

		if (!this.isYouTubeUrl(input.url)) {
			throw this.createError("VALIDATION_ERROR", "Not a valid YouTube URL")
		}
	}

	// ========================================================================
	// YouTubeExtractor Interface
	// ========================================================================

	/**
	 * Extract transcript from YouTube video
	 *
	 * Extracts video transcript with intelligent fallback strategy:
	 * 1. Try to fetch transcript in preferred languages
	 * 2. If transcript fails, generate AI summary using MarkItDown
	 * 3. If all fails, return video metadata only
	 *
	 * @param videoId - YouTube video ID (11 characters)
	 * @param options - Extraction options including language preferences
	 * @returns Extraction result with transcript/summary and video metadata
	 *
	 * @example
	 * ```typescript
	 * // Extract with default languages
	 * const result = await youtubeExtractor.extractTranscript('dQw4w9WgXcQ');
	 *
	 * // Extract with specific languages
	 * const result = await youtubeExtractor.extractTranscript('dQw4w9WgXcQ', {
	 *   preferredLanguages: ['pt', 'pt-BR', 'en'],
	 *   includeAutoGenerated: true,
	 *   minLength: 500
	 * });
	 * ```
	 */
	async extractTranscript(
		videoId: string,
		options?: YouTubeOptions,
	): Promise<ExtractionResult> {
		this.assertInitialized()

		const tracker = this.performanceMonitor.startOperation("extractTranscript")

		try {
			this.logger.info("Extracting YouTube transcript", { videoId })

			// First, try to get metadata
			const metadata = await this.extractMetadata(videoId)

			// Try to get transcript
			let transcript: string | null = null
			let transcriptSource = "none"

			try {
				transcript = await this.getTranscript(videoId, options)
				transcriptSource = "transcript"
			} catch (error) {
				this.logger.warn(
					"Failed to get transcript, falling back to metadata only",
					{
						videoId,
						error: (error as Error).message,
					},
				)
			}

			// If no transcript, try to generate summary from video
			if (!transcript) {
				try {
					const videoUrl = `https://www.youtube.com/watch?v=${videoId}`
					const summary = await summarizeYoutubeVideo(videoUrl)
					if (summary) {
						transcript = summary
						transcriptSource = "ai-summary"
					}
				} catch (error) {
					this.logger.warn("Failed to generate AI summary", {
						videoId,
						error: (error as Error).message,
					})
				}
			}

			// Fallback to metadata if no content
			const content = transcript || this.formatMetadataAsContent(metadata)

			const cleanedContent = this.cleanContent(content)

			tracker.end(true)

			return {
				text: cleanedContent,
				title: metadata.title,
				source: "youtube",
				url: `https://www.youtube.com/watch?v=${videoId}`,
				contentType: "video/youtube",
				raw: {
					metadata,
					videoId,
					transcriptSource,
				},
				wordCount: this.countWords(cleanedContent),
				extractorUsed: "YouTubeExtractor",
				extractionMetadata: {
					videoId,
					channelName: metadata.channelName,
					duration: metadata.duration,
					viewCount: metadata.viewCount,
					uploadDate: metadata.uploadDate,
					availableLanguages: metadata.availableLanguages,
					thumbnailUrl: metadata.thumbnailUrl,
				},
			}
		} catch (error) {
			tracker.end(false)
			throw this.handleError(error, "extractTranscript")
		}
	}

	/**
	 * Extract metadata from YouTube video
	 *
	 * Fetches video information including title, channel, duration, and thumbnails.
	 * Uses the YouTube transcript API as the metadata source.
	 *
	 * @param videoId - YouTube video ID (11 characters)
	 * @returns Video metadata including title, channel, and thumbnail URLs
	 *
	 * @example
	 * ```typescript
	 * const metadata = await youtubeExtractor.extractMetadata('dQw4w9WgXcQ');
	 * console.log(`Title: ${metadata.title}`);
	 * console.log(`Channel: ${metadata.channelName}`);
	 * console.log(`Duration: ${metadata.duration}s`);
	 * ```
	 */
	async extractMetadata(videoId: string): Promise<YouTubeMetadata> {
		this.logger.debug("Extracting YouTube metadata", { videoId })

		// Use fetchYouTubeTranscriptFallback which also returns metadata
		try {
			const result = await fetchYouTubeTranscriptFallback(
				`https://www.youtube.com/watch?v=${videoId}`,
			)

			// Try to get title from metadata first (now extracted from page HTML)
			let title = result?.metadata?.title

			// Fallback: parse the result to extract title from markdown
			if (!title) {
				const markdown = result?.markdown || ""
				const lines = markdown.split("\n")
				title = lines[0]?.replace(/^#\s*/i, "") || undefined
			}

			// Second fallback: use oEmbed API
			if (!title || title === "Unknown") {
				this.logger.debug("Trying oEmbed fallback for title", { videoId })
				const oEmbedTitle = await fetchTitleFromOEmbed(videoId)
				if (oEmbedTitle) {
					title = oEmbedTitle
					this.logger.info("Got title from oEmbed", { videoId, title })
				}
			}

			// Final fallback
			if (!title) {
				title = `YouTube Video ${videoId}`
			}

			return {
				videoId,
				title,
				channelName: "Unknown",
				description: "",
				duration: 0,
				availableLanguages: this.preferredLanguages,
				thumbnailUrl: `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,
			}
		} catch (error) {
			this.logger.warn("Failed to extract metadata, trying oEmbed", {
				videoId,
				error: (error as Error).message,
			})

			// Try oEmbed as fallback
			const oEmbedTitle = await fetchTitleFromOEmbed(videoId)

			// Return minimal metadata with oEmbed title if available
			return {
				videoId,
				title: oEmbedTitle || `YouTube Video ${videoId}`,
				channelName: "Unknown",
				description: "",
				duration: 0,
				availableLanguages: [],
				thumbnailUrl: `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,
			}
		}
	}

	/**
	 * Parse YouTube URL to get video ID
	 *
	 * Extracts 11-character video ID from various YouTube URL formats:
	 * - youtube.com/watch?v=VIDEO_ID
	 * - youtu.be/VIDEO_ID
	 * - youtube.com/embed/VIDEO_ID
	 * - youtube.com/v/VIDEO_ID
	 * - youtube.com/shorts/VIDEO_ID
	 *
	 * @param url - YouTube URL or video ID
	 * @returns 11-character video ID or null if invalid
	 *
	 * @example
	 * ```typescript
	 * const id1 = youtubeExtractor.parseVideoId('https://youtube.com/watch?v=dQw4w9WgXcQ');
	 * // Returns: 'dQw4w9WgXcQ'
	 *
	 * const id2 = youtubeExtractor.parseVideoId('https://youtu.be/dQw4w9WgXcQ');
	 * // Returns: 'dQw4w9WgXcQ'
	 *
	 * const id3 = youtubeExtractor.parseVideoId('dQw4w9WgXcQ');
	 * // Returns: 'dQw4w9WgXcQ'
	 * ```
	 */
	parseVideoId(url: string): string | null {
		// Handle various YouTube URL formats
		const patterns = [
			/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
			/youtube\.com\/v\/([a-zA-Z0-9_-]{11})/,
			/youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})/,
		]

		for (const pattern of patterns) {
			const match = url.match(pattern)
			if (match) return match[1]
		}

		// Check if it's just a video ID
		if (/^[a-zA-Z0-9_-]{11}$/.test(url)) {
			return url
		}

		return null
	}

	/**
	 * Check if URL is a valid YouTube URL
	 */
	isYouTubeUrl(url: string): boolean {
		const lowerUrl = url.toLowerCase()
		return (
			lowerUrl.includes("youtube.com") ||
			lowerUrl.includes("youtu.be") ||
			!!this.parseVideoId(url)
		)
	}

	// ========================================================================
	// Private Methods
	// ========================================================================

	/**
	 * Get transcript for video
	 */
	private async getTranscript(
		videoId: string,
		options?: YouTubeOptions,
	): Promise<string | null> {
		const videoUrl = `https://www.youtube.com/watch?v=${videoId}`

		try {
			let result = await fetchYouTubeTranscriptFallback(videoUrl)
			if (!result) {
				await new Promise((r) => setTimeout(r, 500))
				result = await fetchYouTubeTranscriptFallback(videoUrl)
			}

			if (!result) {
				return null
			}

			// Validate transcript length
			const markdown = result.markdown || ""
			const minLength = options?.minLength ?? 300
			if (markdown.length < minLength) {
				this.logger.warn("Transcript too short", {
					videoId,
					length: markdown.length,
					minLength,
				})
				return null
			}

			return markdown
		} catch (error) {
			this.logger.warn("Failed to fetch transcript", {
				videoId,
				error: (error as Error).message,
			})
			return null
		}
	}

	/**
	 * Format metadata as readable content (fallback)
	 */
	private formatMetadataAsContent(metadata: YouTubeMetadata): string {
		const parts: string[] = []

		parts.push(`Title: ${metadata.title}`)

		if (metadata.channelName) {
			parts.push(`Channel: ${metadata.channelName}`)
		}

		if (metadata.description) {
			parts.push(`\nDescription:\n${metadata.description}`)
		}

		if (metadata.duration > 0) {
			const minutes = Math.floor(metadata.duration / 60)
			const seconds = metadata.duration % 60
			parts.push(
				`\nDuration: ${minutes}:${seconds.toString().padStart(2, "0")}`,
			)
		}

		if (metadata.viewCount) {
			parts.push(`Views: ${metadata.viewCount.toLocaleString()}`)
		}

		if (metadata.uploadDate) {
			parts.push(`Uploaded: ${metadata.uploadDate.toLocaleDateString()}`)
		}

		return parts.join("\n")
	}

	/**
	 * Clean extracted content
	 */
	private cleanContent(content: string): string {
		// Remove null bytes
		let cleaned = content.replace(/\0/g, "")

		// Normalize whitespace
		cleaned = cleaned.replace(/\s+/g, " ")

		// Remove excessive line breaks
		cleaned = cleaned.replace(/\n{3,}/g, "\n\n")

		// Trim
		cleaned = cleaned.trim()

		return cleaned
	}

	/**
	 * Count words in text
	 */
	private countWords(text: string): number {
		const normalized = text.trim()
		if (!normalized) return 0
		return normalized.split(/\s+/).length
	}

	// ========================================================================
	// Lifecycle Hooks
	// ========================================================================

	protected async onHealthCheck(): Promise<boolean> {
		// Check if we can access YouTube
		try {
			const testVideoId = "dQw4w9WgXcQ" // Rick Roll - always available
			const metadata = await this.extractMetadata(testVideoId)
			return !!metadata.title
		} catch {
			return false
		}
	}
}

// ============================================================================
// Factory Function
// ============================================================================

/**
 * Create YouTube extractor with preferred languages
 */
export function createYouTubeExtractor(
	preferredLanguages?: string[],
): YouTubeExtractor {
	return new YouTubeExtractor(preferredLanguages)
}
